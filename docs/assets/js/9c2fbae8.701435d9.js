"use strict";(self.webpackChunkrescript_json=self.webpackChunkrescript_json||[]).push([[517],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>k});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var d=a.createContext({}),p=function(e){var t=a.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(d.Provider,{value:t},e.children)},s="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,d=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),s=p(n),m=r,k=s["".concat(d,".").concat(m)]||s[m]||u[m]||l;return n?a.createElement(k,i(i({ref:t},c),{},{components:n})):a.createElement(k,i({ref:t},c))}));function k(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,i=new Array(l);i[0]=m;var o={};for(var d in t)hasOwnProperty.call(t,d)&&(o[d]=t[d]);o.originalType=e,o[s]="string"==typeof e?e:r,i[1]=o;for(var p=2;p<l;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},2112:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>i,default:()=>u,frontMatter:()=>l,metadata:()=>o,toc:()=>p});var a=n(7462),r=(n(7294),n(3905));const l={sidebar_position:4},i="Json.Decode",o={unversionedId:"modules/json-decode",id:"modules/json-decode",title:"Json.Decode",description:"Turn JSON values into Rescript values",source:"@site/docs/modules/json-decode.md",sourceDirName:"modules",slug:"/modules/json-decode",permalink:"/modules/json-decode",draft:!1,editUrl:"https://github.com/jaredramirez/rescript-json/tree/main/docs/modules/json-decode.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Json",permalink:"/modules/json"},next:{title:"Json.Encode",permalink:"/modules/json-encode"}},d={},p=[{value:"Primitives",id:"primitives",level:2},{value:"<code>t</code>",id:"t",level:3},{value:"<code>value</code>",id:"value",level:3},{value:"<code>string</code>",id:"string",level:3},{value:"<code>bool</code>",id:"bool",level:3},{value:"<code>int</code>",id:"int",level:3},{value:"<code>float</code>",id:"float",level:3},{value:"Data Structures",id:"data-structures",level:2},{value:"<code>nullable</code>",id:"nullable",level:3},{value:"<code>array</code>",id:"array",level:3},{value:"<code>list</code>",id:"list",level:3},{value:"<code>dict</code>",id:"dict",level:3},{value:"<code>keyValuePairs</code>",id:"keyvaluepairs",level:3},{value:"<code>tuple2</code>",id:"tuple2",level:3},{value:"<code>tuple3</code>",id:"tuple3",level:3},{value:"<code>tuple4-8</code>",id:"tuple4-8",level:3},{value:"Object Primatives",id:"object-primatives",level:2},{value:"<code>field</code>",id:"field",level:3},{value:"<code>at</code>",id:"at",level:3},{value:"<code>index</code>",id:"index",level:3},{value:"Inconsistent Structure",id:"inconsistent-structure",level:2},{value:"<code>option</code>",id:"option",level:3},{value:"<code>oneOf</code>",id:"oneof",level:3},{value:"Running Decoders",id:"running-decoders",level:2},{value:"<code>decodeString</code>",id:"decodestring",level:3},{value:"<code>decodeValue</code>",id:"decodevalue",level:3},{value:"<code>error</code>",id:"error",level:3},{value:"<code>errorToString</code>",id:"errortostring",level:3},{value:"Combine",id:"combine",level:2},{value:"<code>map</code>",id:"map",level:3},{value:"<code>map2</code>",id:"map2",level:3},{value:"<code>map3</code>",id:"map3",level:3},{value:"<code>map4-8</code>",id:"map4-8",level:3},{value:"Fancy",id:"fancy",level:2},{value:"<code>value</code>",id:"value-1",level:3},{value:"<code>null</code>",id:"null",level:3},{value:"<code>succeed</code>",id:"succeed",level:3},{value:"<code>succeed</code>",id:"succeed-1",level:3},{value:"<code>andMap</code>",id:"andmap",level:3},{value:"<code>andThen</code>",id:"andthen",level:3}],c={toc:p},s="wrapper";function u(e){let{components:t,...n}=e;return(0,r.kt)(s,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"jsondecode"},(0,r.kt)("inlineCode",{parentName:"h1"},"Json.Decode")),(0,r.kt)("p",null,"Turn JSON values into Rescript values"),(0,r.kt)("h2",{id:"primitives"},"Primitives"),(0,r.kt)("h3",{id:"t"},(0,r.kt)("inlineCode",{parentName:"h3"},"t")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},"type t<'a>\n")),(0,r.kt)("p",null,"A value that knows how to decode JSON values."),(0,r.kt)("h3",{id:"value"},(0,r.kt)("inlineCode",{parentName:"h3"},"value")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},"type value = Js.Json.t\n")),(0,r.kt)("p",null,"Represents a JavaScript value. Alias to ",(0,r.kt)("a",{parentName:"p",href:"./json#value"},(0,r.kt)("inlineCode",{parentName:"a"},"Json.value")),";"),(0,r.kt)("h3",{id:"string"},(0,r.kt)("inlineCode",{parentName:"h3"},"string")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},"let string: t<string>\n")),(0,r.kt)("p",null,"Decode a JSON string into a Rescript ",(0,r.kt)("inlineCode",{parentName:"p"},"string"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},'decodeString("true", string)                   == Error(...)\ndecodeString("42", string)                     == Error(...)\ndecodeString("3.14", string)                   == Error(...)\ndecodeString("\\"hello\\", string)          == Ok("hello")\ndecodeString("{ \\"hello\\": 42 }", string)  == Error(...)\n')),(0,r.kt)("h3",{id:"bool"},(0,r.kt)("inlineCode",{parentName:"h3"},"bool")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},"let bool: t<bool>\n")),(0,r.kt)("p",null,"Decode a JSON bool into a Rescript ",(0,r.kt)("inlineCode",{parentName:"p"},"bool"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},'decodeString("true", bool)                    == Ok(true)\ndecodeString("42", bool)                      == Error(...)\ndecodeString("3.14", bool)                    == Error(...)\ndecodeString("\\"hello\\", bool)           == Error(...)\ndecodeString("{ \\"hello\\": 42 }", bool)   == Error(...)\n')),(0,r.kt)("h3",{id:"int"},(0,r.kt)("inlineCode",{parentName:"h3"},"int")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},"let int: t<int>\n")),(0,r.kt)("p",null,"Decode a JSON int into a Rescript ",(0,r.kt)("inlineCode",{parentName:"p"},"int"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},'decodeString("true", int)                  == Error(...)\ndecodeString("42", int)                    == Ok(42)\ndecodeString("3.14", int)                  == Error(...)\ndecodeString("\\"hello\\", int)         == Error(...)\ndecodeString("{ \\"hello\\": 42 }", int) == Error(...)\n')),(0,r.kt)("h3",{id:"float"},(0,r.kt)("inlineCode",{parentName:"h3"},"float")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},"let float: t<float>\n")),(0,r.kt)("p",null,"Decode a JSON float into a Rescript ",(0,r.kt)("inlineCode",{parentName:"p"},"float"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},'decodeString("true", float)                  == Error(...)\ndecodeString("42", float)                    == Error(...)\ndecodeString("3.14", float)                  == Ok(3.14)\ndecodeString("\\"hello\\", float)         == Error(...)\ndecodeString("{ \\"hello\\": 42 }", float) == Error(...)\n')),(0,r.kt)("h2",{id:"data-structures"},"Data Structures"),(0,r.kt)("h3",{id:"nullable"},(0,r.kt)("inlineCode",{parentName:"h3"},"nullable")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},"let nullable: t<'a> => t<option<'a>>\n")),(0,r.kt)("p",null,"Decode a nullable JSON value into a Rescript value."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},'decodeString("13", nullable(int))   == Ok(Some(13))\ndecodeString("42", nullable(int))   == Ok(Some(42))\ndecodeString("null", nullable(int)) == Ok(None)\ndecodeString("true", nullable(int)) == Error(...)\n')),(0,r.kt)("h3",{id:"array"},(0,r.kt)("inlineCode",{parentName:"h3"},"array")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},"let array: t<'a> => t<array<'a>> \n")),(0,r.kt)("p",null,"Decode a JSON value into a Rescript ",(0,r.kt)("inlineCode",{parentName:"p"},"array"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},'decodeString("[1,2,3]", array(int))      == Ok([1, 2, 3])\ndecodeString("[true,false]", array(int)) == Ok([true, false])\n')),(0,r.kt)("h3",{id:"list"},(0,r.kt)("inlineCode",{parentName:"h3"},"list")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},"let list: t<'a> => t<list<'a>> \n")),(0,r.kt)("p",null,"Decode a JSON value into a Rescript ",(0,r.kt)("inlineCode",{parentName:"p"},"list"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},'decodeString("[1,2,3]", list(int))      == Ok(list{1, 2, 3})\ndecodeString("[true,false]", list(int)) == Ok(list{true, false})\n')),(0,r.kt)("h3",{id:"dict"},(0,r.kt)("inlineCode",{parentName:"h3"},"dict")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},"let dict: t<'a> => t<Js.Dict.<'a>> \n")),(0,r.kt)("p",null,"Decode a JSON value into a Rescript ",(0,r.kt)("inlineCode",{parentName:"p"},"dict"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},'decodeString("{ \\"alice\\": 42, \\"bob\\": 99 }", dict(int))\n    == Ok(Js.Dict.fromArray([("alice", 42), ("bob", 99)]))\n')),(0,r.kt)("h3",{id:"keyvaluepairs"},(0,r.kt)("inlineCode",{parentName:"h3"},"keyValuePairs")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},"let keyValuePairs: t<'a> => t<array<(string, 'a)>>\n")),(0,r.kt)("p",null,"Decode a JSON value into a Rescript ","[array]"," of pair."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},'decodeString("{ \\"alice\\": 42, \\"bob\\": 99 }", keyValuePairs(int))\n    == Ok([("alice", 42), ("bob", 99)])\n')),(0,r.kt)("h3",{id:"tuple2"},(0,r.kt)("inlineCode",{parentName:"h3"},"tuple2")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},"let tuple2: (t<'a>, t<'b>) => t<('a, 'b)>\n")),(0,r.kt)("p",null,"Decode a JSON value into a Rescript tuple with 2 elements."),(0,r.kt)("p",null,"This is helpful if you're dealing with a heterogeneous JSON array, like ",(0,r.kt)("inlineCode",{parentName:"p"},'[1, "hey"]'),". ",(0,r.kt)("em",{parentName:"p"},"Modeling your JSON like this is generally a bad idea.")," Unfortunately, we sometimes have to use JSON/JavaScript from places outside our control, hence these functions."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},'decodeString("[1, \\"hey\\"]", tuple2(int, string))\n    == Ok((1, "hey"))\n')),(0,r.kt)("h3",{id:"tuple3"},(0,r.kt)("inlineCode",{parentName:"h3"},"tuple3")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},"let tuple3: (t<'a>, t<'b>, t<'c>) => t<('a, 'b, 'c)>\n")),(0,r.kt)("p",null,"Decode a JSON value into a Rescript tuple with 3 elements."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},'decodeString("[1, 8.0, \\"hey\\"]", tuple3(int, float, string))\n    == Ok((1, 8., "hey"))\n')),(0,r.kt)("h3",{id:"tuple4-8"},(0,r.kt)("inlineCode",{parentName:"h3"},"tuple4-8")),(0,r.kt)("p",null,"For ",(0,r.kt)("inlineCode",{parentName:"p"},"tuple4"),"-",(0,r.kt)("inlineCode",{parentName:"p"},"tuple8"),", using it is just like the examples for ",(0,r.kt)("inlineCode",{parentName:"p"},"tuple2")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"tuple3")," only with more elements & decoders."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},"let tuple4: (t<'a>, t<'b>, t<'c>, t<'d>) => t<('a, 'b, 'c, 'd)>\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},"let tuple5: (t<'a>, t<'b>, t<'c>, t<'d>, t<'e>) => t<('a, 'b, 'c, 'd, 'e)>\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},"let tuple6: (t<'a>, t<'b>, t<'c>, t<'d>, t<'e>, t<'f>) => t<('a, 'b, 'c, 'd, 'e, 'f)>\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},"let tuple7: (t<'a>, t<'b>, t<'c>, t<'d>, t<'e>, t<'f>, t<'g>) => t<('a, 'b, 'c, 'd, 'e, 'f, 'g)>\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},"let tuple8: (\n  t<'a>,\n  t<'b>,\n  t<'c>,\n  t<'d>,\n  t<'e>,\n  t<'f>,\n  t<'g>,\n  t<'h>,\n) => t<('a, 'b, 'c, 'd, 'e, 'f, 'g, 'h)>\n")),(0,r.kt)("h2",{id:"object-primatives"},"Object Primatives"),(0,r.kt)("h3",{id:"field"},(0,r.kt)("inlineCode",{parentName:"h3"},"field")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},"let field: (string, t<'a>) => t<'a>\n")),(0,r.kt)("p",null,"Decode a JSON object, requiring a particular field."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},'decodeString("{ \\"x\\": 42 }",                 field("x", int))== Ok(42)\ndecodeString("{ \\"x\\": 42, \\"y\\": 50 }",  field("x", int))== Ok(42)\ndecodeString("{ \\"x\\": true }",               field("x", int))== Error(...)\ndecodeString("{ \\"y\\": 50 }",                 field("x", int))== Error(...)\n')),(0,r.kt)("p",null,"The object ",(0,r.kt)("em",{parentName:"p"},"can")," have other fields. Lots of them! The only thing this decoder cares about is if ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," is present and that the value there is an ",(0,r.kt)("inlineCode",{parentName:"p"},"int"),"."),(0,r.kt)("p",null,"Check out ",(0,r.kt)("a",{parentName:"p",href:"#map2"},(0,r.kt)("inlineCode",{parentName:"a"},"map2"))," to see how to decode multiple fields!"),(0,r.kt)("h3",{id:"at"},(0,r.kt)("inlineCode",{parentName:"h3"},"at")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},"let at: (string, array<string>, t<'a>) => t<'a>\n")),(0,r.kt)("p",null,"Decode a nested JSON object, requiring certain fields."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},'let json = "{ \\"person\\": { \\"name\\": \\"Maria\\", \\"age\\": 24 } }"\n\ndecodeString(json, at(["person", "name"], string)) == Ok("Maria")\ndecodeString(json, at(["person", "age" ], int   )) == Ok(24)\n')),(0,r.kt)("p",null,"This is really just a shorthand for saying things like:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},'field("person", field("name", string)) == at(["person", "name"], string)\n')),(0,r.kt)("h3",{id:"index"},(0,r.kt)("inlineCode",{parentName:"h3"},"index")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},"let index: (int, t<'a>) => t<'a>\n")),(0,r.kt)("p",null,"Decode a nested JSON object, requiring a certain index."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},'let json = "[ \\"Maria\\", \\"Caleb\\", \\"Sofia\\" ]"\n\ndecodeString(json, index(0, string)) == Ok("Maria")\ndecodeString(json, index(2, string)) == Ok("Sofia")\n')),(0,r.kt)("h2",{id:"inconsistent-structure"},"Inconsistent Structure"),(0,r.kt)("h3",{id:"option"},(0,r.kt)("inlineCode",{parentName:"h3"},"option")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},"let option: t<'a> => t<option<'a>>\n")),(0,r.kt)("p",null,"Helpful for dealing with optional fields. Here are a few slightly different examples:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},'let json = "{ \\"name\\": \\"Maria\\", \\"age\\": 24 }"\n\ndecodeString(json, option(field("age",    int  ))) == Ok(Some(24))\ndecodeString(json, option(field("name",   int  ))) == Ok(None)\ndecodeString(json, option(field("height", float))) == Ok(None)\n\ndecodeString(json, field("age", option(float))) == Ok(Some(24))\ndecodeString(json, field("name", option(float))) == Ok(None)\ndecodeString(json, field("height", option(float))) == Error(...)\n')),(0,r.kt)("p",null,"Notice the last example! It is saying we ",(0,r.kt)("em",{parentName:"p"},"must")," have a field named ",(0,r.kt)("inlineCode",{parentName:"p"},"height")," and the content ",(0,r.kt)("em",{parentName:"p"},"may")," be a ",(0,r.kt)("inlineCode",{parentName:"p"},"float"),". There is no ",(0,r.kt)("inlineCode",{parentName:"p"},"height")," field, so the decoder fails."),(0,r.kt)("p",null,"Point is, ",(0,r.kt)("inlineCode",{parentName:"p"},"option")," will make exactly what it contains conditional. For optional fields, this means you probably want it ",(0,r.kt)("em",{parentName:"p"},"outside")," a use of ",(0,r.kt)("a",{parentName:"p",href:"#field"},(0,r.kt)("inlineCode",{parentName:"a"},"field"))," or ",(0,r.kt)("a",{parentName:"p",href:"#at"},(0,r.kt)("inlineCode",{parentName:"a"},"at")),"."),(0,r.kt)("h3",{id:"oneof"},(0,r.kt)("inlineCode",{parentName:"h3"},"oneOf")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},"let oneOf: (t<'a>, array<t<'a>>) => t<'a>\n")),(0,r.kt)("p",null,"Try a bunch of different decoders. This can be useful if the JSON may come in a couple different formats. For example, say you want to read an array of numbers, but some of them are ","[null]","."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},'let badIntDecoder: t<int> =\noneOf(\n  int, // the first decoder to try\n  [null(0)] // the other decoders to try\n)\n\ndecodeString("[1,2,null,4]", badIntDecoder) == Ok([1, 2, 0, 4])\n')),(0,r.kt)("p",null,"Why would someone generate JSON like this? Questions like this are not good for your health. Point is, that you can use ",(0,r.kt)("inlineCode",{parentName:"p"},"oneOf"),"\tto handle situations like this!"),(0,r.kt)("p",null,"You could also use ",(0,r.kt)("inlineCode",{parentName:"p"},"oneOf")," to help version your data. Try the latest format, then a few older ones that you still support. You could use ",(0,r.kt)("a",{parentName:"p",href:"#andThen"},(0,r.kt)("inlineCode",{parentName:"a"},"andThen"))," to be even more particular if you wanted."),(0,r.kt)("h2",{id:"running-decoders"},"Running Decoders"),(0,r.kt)("h3",{id:"decodestring"},(0,r.kt)("inlineCode",{parentName:"h3"},"decodeString")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},"let decodeString: (string, t<'a>) => result<'a, error>\n")),(0,r.kt)("p",null,"Parse the given string into a JSON value and then run the decoder on it. This will fail if the string is not well-formed JSON or if the Decoder fails for some reason."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},'  decodeString(\\"1\\", int)     == Ok(1)\n  decodeString(\\"1 + 2\\", int) == Error(...)\n')),(0,r.kt)("h3",{id:"decodevalue"},(0,r.kt)("inlineCode",{parentName:"h3"},"decodeValue")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},"let decodeValue: (value, t<'a>) => result<'a, error>\n")),(0,r.kt)("p",null,"Run a decoder on some JSON ",(0,r.kt)("inlineCode",{parentName:"p"},"value"),". This is helpful if you want to bring in some JavaScript value as a ",(0,r.kt)("inlineCode",{parentName:"p"},"value"),", then run a decoder on it."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},'@module(\\"my-func\\")\nexternal getUser: unit => value = \\"default\\"\n\nlet firstNameDecoder: t<string> =\n  oneOf(\n    field(\\"firstName\\", string),\n    [\n      field(\\"first_name\\", string),\n      field(\\"first-name\\", string),\n    ]\n  )\n\nlet myFunc = () => {\n  getUser()\n    ->decodeValue(firstNameDecoder)\n}\n')),(0,r.kt)("h3",{id:"error"},(0,r.kt)("inlineCode",{parentName:"h3"},"error")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},"type rec error =\n  | Failure(string, value)\n  | Index(int, error)\n  | Field(string, error)\n  | OneOf(error, array<error>)\n")),(0,r.kt)("p",null,"A structured error describing exactly how the decoder failed. You can use this to create more elaborate visualizations of a decoder problem. For example, you could show the entire JSON object and show the part causing the failure in red."),(0,r.kt)("h3",{id:"errortostring"},(0,r.kt)("inlineCode",{parentName:"h3"},"errorToString")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},"let errorToString: error => string\n")),(0,r.kt)("p",null,"Convert a decoding error into a ","[string]"," that is nice for debugging. The output of this function produces a multi-line string."),(0,r.kt)("p",null,"For example, the following decoder"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},'decodeString(`{ \\"a\\": { \\"b\\": \\"hey\\" } }`, at(\\"a\\", [\\"b\\"], int))\n')),(0,r.kt)("p",null,"produces the string"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'Problem with the value at json["a"]["b"]:\n\n"hey"\n\nExpecting an INT\n')),(0,r.kt)("h2",{id:"combine"},"Combine"),(0,r.kt)("p",null,"Note: If you run out of map functions, take a look at ",(0,r.kt)("a",{parentName:"p",href:"#andMap"},(0,r.kt)("inlineCode",{parentName:"a"},"andMap")),"} which makes it easier to handle large objects, but produces lower quality type errors."),(0,r.kt)("h3",{id:"map"},(0,r.kt)("inlineCode",{parentName:"h3"},"map")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},"let map: (t<'a>, ~f: 'a => 'b) => t<'b>\n")),(0,r.kt)("p",null,"Transform a decoder. Maybe you just want to know the length of a string:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},"let stringLength: t<int> = map(string, ~f=Js.String.length)\n")),(0,r.kt)("p",null,"It is often helpful to use ",(0,r.kt)("inlineCode",{parentName:"p"},"map")," with ",(0,r.kt)("a",{parentName:"p",href:"#oneOf"},(0,r.kt)("inlineCode",{parentName:"a"},"oneOf")),", like when defining ",(0,r.kt)("a",{parentName:"p",href:"#nullable"},(0,r.kt)("inlineCode",{parentName:"a"},"nullable")),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},"let nullable = (decoder: t<'a>): t<option<'a>> =\n  oneOf(\n    null(None),\n    [map(decoder, ~f=val => Some(val))]\n  )\n")),(0,r.kt)("h3",{id:"map2"},(0,r.kt)("inlineCode",{parentName:"h3"},"map2")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},"let map2: (t<'a>, t<'b>, ~f: ('a, 'b) => 'c) => t<'c>\n")),(0,r.kt)("p",null,"Try two decoders and then combine the result. We can use this to decode objects with many fields:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},'type point = { x: float, y: float }\n\nlet pointDecoder =\n  map2(\n    field("x", float),\n    field("y", float),\n    ~f=(x, y) => { x: x, y: y })\n  )\n\nlet json = "{ \\"x\\": 2, \\"y\\": 5 }"\ndecodeString(json, pointDecoder) == Ok({ x: 2, y: 5 })\n')),(0,r.kt)("p",null,"It tries each individual decoder and puts the result together with in the ",(0,r.kt)("inlineCode",{parentName:"p"},"~f")," function."),(0,r.kt)("h3",{id:"map3"},(0,r.kt)("inlineCode",{parentName:"h3"},"map3")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},"let map3: (t<'a>, t<'b>, t<'c>, ~f: ('a, 'b, 'c) => 'val) => t<'val>\n")),(0,r.kt)("p",null,"Try three decoders and then combine the result. We can use this to decode objects with many fields:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},'type person = { name: string, age: int, height: float }\n\nlet pointDecoder =\n  map3(\n    field("name", string),\n    at("info", ["age"], int),\n    at("info", ["height"], float),\n    ~f=(name, age, height) => { name: name, age: age, height: height })\n  )\n\nlet json = "{ \\"name\\": "Maria", \\"info\\": { \\"age\\": 28, \\"height\\": 1.5 } }"\ndecodeString(json, pointDecoder)\n  == Ok({ name: "Maria", age: 28, height: 1.5 })\n')),(0,r.kt)("p",null,"It tries each individual decoder and puts the result together with in the ",(0,r.kt)("inlineCode",{parentName:"p"},"~f")," function."),(0,r.kt)("h3",{id:"map4-8"},(0,r.kt)("inlineCode",{parentName:"h3"},"map4-8")),(0,r.kt)("p",null,"For ",(0,r.kt)("inlineCode",{parentName:"p"},"map4"),"-",(0,r.kt)("inlineCode",{parentName:"p"},"map8"),", using it is just like the examples for ",(0,r.kt)("inlineCode",{parentName:"p"},"map2")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"map3")," only with more elements & decoders."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},"let map4: (t<'a>, t<'b>, t<'c>, t<'d>, ~f: ('a, 'b, 'c, 'd) => 'val) => t<'val>\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},"let map5: (t<'a>, t<'b>, t<'c>, t<'d>, t<'e>, ~f: ('a, 'b, 'c, 'd, 'e) => 'val) => t<'val>\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},"let map6: (\n  t<'a>,\n  t<'b>,\n  t<'c>,\n  t<'d>,\n  t<'e>,\n  t<'f>,\n  ~f: ('a, 'b, 'c, 'd, 'e, 'f) => 'val,\n) => t<'val>\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},"let map7: (\n  t<'a>,\n  t<'b>,\n  t<'c>,\n  t<'d>,\n  t<'e>,\n  t<'f>,\n  t<'g>,\n  ~f: ('a, 'b, 'c, 'd, 'e, 'f, 'g) => 'val,\n) => t<'val>\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},"let map8: (\n  t<'a>,\n  t<'b>,\n  t<'c>,\n  t<'d>,\n  t<'e>,\n  t<'f>,\n  t<'g>,\n  t<'h>,\n  ~f: ('a, 'b, 'c, 'd, 'e, 'f, 'g, 'h) => 'val,\n) => t<'val>\n")),(0,r.kt)("h2",{id:"fancy"},"Fancy"),(0,r.kt)("h3",{id:"value-1"},(0,r.kt)("inlineCode",{parentName:"h3"},"value")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},"let value: t<value>\n")),(0,r.kt)("p",null,"Do not do anything with a JSON value, just bring it into Rescript as a ",(0,r.kt)("a",{parentName:"p",href:"#value"},(0,r.kt)("inlineCode",{parentName:"a"},"value")),". This can be useful if you have particularly complex data that you would like to deal with later. Or if you are going to send it out another ",(0,r.kt)("inlineCode",{parentName:"p"},"external")," and do not care about its structure."),(0,r.kt)("h3",{id:"null"},(0,r.kt)("inlineCode",{parentName:"h3"},"null")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},"let null: 'a => t<'a>\n")),(0,r.kt)("p",null,"Decode a JSON string into some Rescript value."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},'decodeString("null", null(false)) == Ok(false)\ndecodeString("null", null(42))    == Ok(42)\ndecodeString("42", null(42))      == Error(...)\ndecodeString("false", null(42))   == Error(...)\n')),(0,r.kt)("h3",{id:"succeed"},(0,r.kt)("inlineCode",{parentName:"h3"},"succeed")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},"let succeed: 'a => t<'a>\n")),(0,r.kt)("p",null,"Ignore the JSON and produce a certain Rescript value."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},'decodeString("true", succeed(42))    == Ok(42)\ndecodeString("[1,2,3]", succeed(42)) == Ok(42)\ndecodeString("hello", succeed(42))   == Error(...) // "hello" is not a valid JSON string, so this fails\n')),(0,r.kt)("h3",{id:"succeed-1"},(0,r.kt)("inlineCode",{parentName:"h3"},"succeed")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},"let fail: string => t<'a>\n")),(0,r.kt)("p",null,"Ignore the JSON and make the decoder fail. This is handy when used with ",(0,r.kt)("a",{parentName:"p",href:"#oneOf"},(0,r.kt)("inlineCode",{parentName:"a"},"oneOf"))," or ",(0,r.kt)("a",{parentName:"p",href:"#andThen"},(0,r.kt)("inlineCode",{parentName:"a"},"andThen"))," where you want to give a custom error message in some case."),(0,r.kt)("p",null,"See the ",(0,r.kt)("a",{parentName:"p",href:"#andThen"},(0,r.kt)("inlineCode",{parentName:"a"},"andThen"))," docs for an example."),(0,r.kt)("h3",{id:"andmap"},(0,r.kt)("inlineCode",{parentName:"h3"},"andMap")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},"let andMap: (t<'a => 'b>, t<'a>) => t<'b>\n")),(0,r.kt)("p",null,"Chain decoders together and then transfrom them all together. This is very often going to be used with ",(0,r.kt)("a",{parentName:"p",href:"#succeed"},(0,r.kt)("inlineCode",{parentName:"a"},"succeed")),"."),(0,r.kt)("p",null,"If you want to define ",(0,r.kt)("a",{parentName:"p",href:"#map3"},(0,r.kt)("inlineCode",{parentName:"a"},"map3")),", you could do:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},"let map3: (t<'a>, t<'b>, t<'c>, ~f: ('a, 'b, 'c) => 'val) => t<'val> = (\n  decoderA,\n  decoderB,\n  decoderC,\n  ~f,\n) =>\n  succeed(f)\n    ->andMap(decoderA)\n    ->andMap(decoderB)\n    ->andMap(decoderC)\n")),(0,r.kt)("p",null,"You can use this function to chain together ",(0,r.kt)("inlineCode",{parentName:"p"},"field")," decoders to construct a Rescript record from a JSON one:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},'type t = { id: int, name: string }\n\nlet decoder: Json.Decode.t<t> = {\n  open Json.Decode\n  succeed((id, name) => { id: id, name: name })\n  ->andMap(field("id", int))\n  ->andMap(field("name", string))\n\ndecodeString(`{ "id": 1, "name": "Marcos" }`, decoder) == { id: 1, name: "Marcos" }\n}  \n')),(0,r.kt)("p",null,"This is style of decoding is sometimes called pipeline decoding!"),(0,r.kt)("h3",{id:"andthen"},(0,r.kt)("inlineCode",{parentName:"h3"},"andThen")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},"let andThen: (t<'a>, ~f: 'a => t<'b>) => t<'b>\n")),(0,r.kt)("p",null,"Create decoders that depend on previous results. If you are creating versioned data, you might do something like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},'let infoDecoder1: t<info> = x\nlet infoDecoder2: t<info> = y\nlet infoDecoder3: t<info> = z\n\nlet infoDecoder = (version: int): t<info> =\n  switch version {\n  | 1 => infoDecoder1\n  | 2 => infoDecoder2\n  | 3 => infoDecoder3\n  | _ => fail(`Trying to decode info, but version ${Belt.Int.toString(version)} is not supported`)\n  }\n\nlet info: t<info> =\n  field("version", int)\n    ->andThen(~f=infoDecoder)\n')))}u.isMDXComponent=!0}}]);